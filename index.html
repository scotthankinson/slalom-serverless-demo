<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Serverless Compute</title>

		<meta name="description" content="Building full stack websites with minimal infrastructure">
		<meta name="author" content="Scott Hankinson">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/beige.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Serverless Compute</h1>
					<h4>Building full stack websites with minimal infrastructure</h4>
					<br>
					<p>
						<small>Created by Scott Hankinson</a> / Slalom Consulting</small>
					</p>
				</section>

				<section>
					<section>
						<h2>What is Serverless?</h2>
						<small>
							<q cite="https://en.wikipedia.org/wiki/Serverless_computing">
								&ldquo;Serverless computing, also known as function as a service (FaaS), is a cloud computing code execution model in which the cloud provider fully manages starting and stopping of a function's container platform as a service (PaaS) as necessary to serve requests, and requests are billed by an abstract measure of the resources required to satisfy the request, rather than per virtual machine, per hour.&rdquo;
							</q>
						</small>
					</section>
					<section>
						<small>
							<q cite="https://en.wikipedia.org/wiki/Serverless_computing">
								<b>&ldquo;Despite the name, it does not actually involve running code without servers</b>. The name "serverless computing" is used because the business or person that owns the system does not have to purchase, rent or provision servers or virtual machines for the back-end code to run on.&rdquo;
								<br>
								<br>
								Miller, Ron (24 Nov 2015). <a href="https://techcrunch.com/2015/11/24/aws-lamda-makes-serverless-applications-a-reality/">"AWS Lambda Makes Serverless Applications A Reality"</a>
							</q>
						</small>
					</section>
				</section>
				
				<section>
					<section>
						<h2>Who are the providers?</h2>
						<img data-src="assets/providers_black.png"></img>
						<p>
							<small>AWS is regarded as the first major cloud provider to offer Serverless Functions, debuting AWS Lambda at re:Invent in 2014.  IBM OpenWhisk and Microsoft Azure Functions became generally available in 2016, and as of this writing Google Cloud Functions have just entered public beta.</small>
						</p>
					</section>
					<section>
						<h2>What does this presentation cover?</h2>
						<img data-src="assets/AWS_BW.png"></img>
						<p>
							<small>Practical experience and ready to demo code mean that this presentation focuses largely on AWS tooling and components.  Many of the concepts may be transferable, but the core lens we will be using is Amazon Web Services </small>
						</p>
					</section>
				</section>
				
				<section>
					<section>
						<h2>What languages are supported?</h2>
						<p>
							<img data-src="assets/Lambda_Inline.PNG"></img>
							<small>NodeJS and Python support in-line code editing for quick testing, while Java and C# require deployment packages.  For any complex function, deployment packages will be a must.</small>
						</p>
					</section>
					<section>
						<h2>NodeJS 4.3</h2>
						<pre><code class="hljs" data-trim contenteditable>
'use strict';

console.log('Loading function');

exports.handler = (event, context, callback) => {
    //console.log('Received event:', JSON.stringify(event, null, 2));
    console.log('value1 =', event.key1);
    console.log('value2 =', event.key2);
    console.log('value3 =', event.key3);
    callback(null, event.key1);  // Echo back the first key value
    //callback('Something went wrong');
};

						</code></pre>
					</section>
					<section>
						<h2>Python 2.7</h2>
						<pre><code class="hljs" data-trim contenteditable>
from __future__ import print_function

import json

print('Loading function')

def lambda_handler(event, context):
    #print("Received event: " + json.dumps(event, indent=2))
    print("value1 = " + event['key1'])
    print("value2 = " + event['key2'])
    print("value3 = " + event['key3'])
    return event['key1']  # Echo back the first key value
    #raise Exception('Something went wrong')

						</code></pre>
					</section>
					<section>
						<h2>Java 8</h2>
						<pre><code class="hljs" data-trim contenteditable>
package example;

import com.amazonaws.services.lambda.runtime.Context; 
import com.amazonaws.services.lambda.runtime.LambdaLogger;

public class Hello {
    public String myHandler(int myCount, Context context) {
        LambdaLogger logger = context.getLogger();
        logger.log("received : " + myCount);
        return String.valueOf(myCount);
    }
}

						</code></pre>
					</section>
					<section>
						<h2>C#</h2>
						<pre><code class="hljs" data-trim contenteditable>
using Amazon.Lambda.Core; 
namespace LambdaFunctionExample{
public class Hello {
    public string MyHandler(int count, ILambdaContext context) {
        var logger = context.Logger;
        logger.log("received : " + count);
        return count.ToString();
    }
  }
}

						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h2>How does it work?</h2>
						<img data-src="assets/Lambda_HowItWorks.png"></img>
					</section>
					<section>
						<h3>Web Applications</h3>
						<img data-src="assets/Lambda_WebApplications.png"></img>
					</section>
					<section>
						<h3>Mobile Backends</h3>
						<img data-src="assets/Lambda_MobileBackends.png"></img>
					</section>
					<section>
						<h3>ETL</h3>
						<img data-src="assets/Lambda_ETL.png"></img>
					</section>
					<section>
						<h3>Real-time File Processing</h3>
						<img data-src="assets/Lambda_FileProcessing.png"></img>
					</section>
					<section>
						<h3>Real-time Stream Processing</h3>
						<img data-src="assets/Lambda_StreamProcessing.png"></img>
					</section>
					<section>
						<h3>IoT Backends</h3>
						<img data-src="assets/Lambda_IoT.png"></img>
					</section>
				</section>

				<section>
					<section>
						<h2>Reference Architecture Time!</h2>
					</section>
					<section>
						<h2>Traditional Web Architecture</h2>
						<img width="500" height="auto" data-src="assets/WebArchitecture.png"</img>
					</section>
					<section>
						<h2>Serverless Architecture</h2>
						<img width="400" height="auto" data-src="assets/ServerlessArchitecture.png"</img>
					</section>
				</section>

				<section>
					<section>
						<h2>Organization and Automation</h2>
						<p>
							<small>Lambda sounds awesome!  What happens when I have something bigger than hello world?</small>
							<small>How do I manage my-awesome-function across lifecycles?</small>
							<small>Are there convenient ways of grouping shared functionality?</small>
						</p>
					</section>
					<section>
						<h2>Organization - Front End</h2>
						<p>
							<small>Use a different CloudFront distrubtion for each lifecycle</small>
						</p>
						<p>
							<small class="fragment">Create a different bucket for each Lifecycle</small>
						</p>
						<p>
							<small class="fragment">Consider storing multiple versions of your application in a staging bucket to allow for blue-green deployments</small>
						</p>
						<p>
							<small class="fragment">For continuous integration, automate dropping the right config file for that environment before syncing</small>
						</p>
						<p>
							<small class="fragment">Remember, anything in the bucket is publicly accessible -- don't put API keys in here!</small>
						</p>
					</section>
					<section>
						<h2>Automation - Front End</h2>
						<pre><code class="hljs" data-trim contenteditable>
stage('update environment'){
    node {
        echo '@@@@ Setting Environment Variables File for DEV @@@@'
        sh "rm ./www/assets/json/env.json"
        sh "rm ./www/assets/json/env.qa.json"
        sh "rm ./www/assets/json/env.prod.json"
        sh "mv ./www/assets/json/env.dev.json ./www/assets/json/env.json"        
    }
}
stage('deploy') {
    node {
        withCredentials([
            string(credentialsId: 'AWS_ACCESS_KEY_ID', variable: 'AWS_ACCESS_KEY_ID'),
            string(credentialsId: 'AWS_SECRET_ACCESS_KEY', variable: 'AWS_SECRET_ACCESS_KEY')]) {
                sh '''aws s3 sync ./www s3://$BUCKET --delete'''
            }
    }
}
						</code></pre>
					</section>
					<section>
						<h2>Organization - Back End</h2>
						<p>
							<small>How do you manage routes across multiple API Gateways leveraging multiple groups of Lamba Functions?</small>
							<img class="fragment" data-src="assets/serverless-logo.png"></img>
						</p>
					</section>
					<section>
						<h2>Organization - Back End</h2>
						<img width="300px" data-src="assets/serverless-logo.png"></img>
						<p>
							<small>Serverless Framework provides a way of describing a serverless "application", and then handles generating the CloudFormation to deploy these functions as a unit.</small>
						</p>
						<p>
							<small class="fragment">Multiple Serverless Framework applications may then be rolled up under a single API Gateway to generate the public facing API layer.</small>
						</p>
						<p>
							<small class="fragment">Group like code with like in the repository, and have Jenkins issue the command 'serverless deploy' to update the code</small>
						</p>
					</section>
					<section>
						<h2>Organization - Back End</h2>
						<img data-src="assets/GatewayOfGateways.png"></img>
					</section>
					<section>
						<h2>Automation - Back End</h2>
						<img data-src="assets/ServerlessDeploy.png"></img>
					</section>
				</section>

				<section>
					<h2>Demo</h2>
					<ol>
						<li>Route 53 / DNS Configuration</li>
						<li>Front End - CloudFormation and S3</li>
						<li>Back End - Serverless Framework</li>
					</ol>
				</section>

				<section>
					<section>
						<h2>Caveats</h2>
						<h3><small>All Web content must be static</small></h3>
						<p>
							<small class="fragment">We already follow this architectural pattern in may places -- static web content fueled by disconnected backend APIs using OAuth or OpenId.</small>
						</p>
						<p>
							<small class="fragment">Angular and Ionic are excellent choices for cross-platform development -- the same site runs on Android, iOS, and web.</small>
						</p>
					</section>
					<section>
						<h2>Caveats</h2>
						<h3><small>All APIs should be stateless</small></h3>
						<p>
							<small class="fragment">Functions should not rely on state stored to memory or disk, and have limited access to the underlying hardware and environment.</small>
						</p>
						<p>
							<small class="fragment">Consider using DynamoDB, Redis, or S3 to store stateful information.</small>
						</p>
						<p>
							<small class="fragment">Keep your functions lean -- too many items in startup lead to slow bloated functions.</small>
						</p>
					</section>
					<section>
						<h2>Caveats</h2>
						<h3><small>Database interactions can become trickier without a REST interface</small></h3>
						<p>
							<small class="fragment">There are strategies for sharing a connection pool, but you are not guaranteed to be able to re-use containers across invocations.  Best effort applies.</small>
						</p>
						<p>
							<small class="fragment">For high throughput, a traditional ORM-backed server environment may still be required.</small>
						</p>
						<p>
							<small class="fragment">Where possible, consider using DynamoDB or any other data layer with ready to use REST APIs.</small>
						</p>
					</section>
					<section>
						<h2>Caveats</h2>
						<h3><small>Environment variables can become tricker without an environment</small></h3>
						<p>
							<small class="fragment">How do you define an environment variable in S3?</small>
						</p>
						<p>
							<small class="fragment">Static config files must be hot-swapped per environment.</small>
						</p>
						<p>
							<small class="fragment">Lambda supports container-level environment variables.</small>
						</p>
					</section>
					<section>
						<h2>Caveats</h2>
						<h3><small>5 minute execution limit</small></h3>
						<p>
							<small class="fragment">For long-running processes (file upload/download, ETL, long polling jobs), consider using traditional servers.</small>
						</p>
						<p>
							<small class="fragment">For jobs which can be chunked, it is possible to 'save and continue' by doing a slice of work and then recursing.</small>
						</p>
						<p>
							<small class="fragment">The default timeout is 3s, and the most cost effective model for execution is quick burst.  Any functions which regularly take over a minute may be good candidates for traditional servers.</small>
						</p>
					</section>
				</section>

				<section style="text-align: left;">
					<h2>References</h2>
					<p>
						- <a href="https://aws.amazon.com/s3/">AWS S3 -- serverless front end of choice</a> <br>
						- <a href="https://aws.amazon.com/lambda/">AWS Lambda -- serverless back end of choice</a> <br>
						- <a href="https://aws.amazon.com/api-gateway/">AWS API Gateway -- the REST glue to our lambda functions</a> <br>
						- <a href="https://serverless.com/">Serverless Framework -- deployment specialists</a> <br>
						- <a href="https://github.com/hakimel/reveal.js">Reveal.js -- what this presentation was built with</a>
					</p>
				</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
